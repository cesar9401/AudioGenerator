
package com.cesar31.audiogenerator.parser;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import com.cesar31.audiogenerator.instruction.*;

class AudioParser;

parser code {:
	public AudioParser(AudioLex lex) {
		super(lex);
	}

	public void syntax_error(Symbol cur_token) {
		List<String> expected = new ArrayList<>();
		List<Integer> tokens = expected_token_ids();

		System.out.printf("Se encontro: %s -> (%s), linea %d columna %d, se esperaba -> ", cur_token.value, symbl_name_from_id(cur_token.sym), cur_token.left, cur_token.right);
		for(Integer i : tokens) {
			// expected.add(symbl_name_from_id(i));
			System.out.printf("%s, ", symbl_name_from_id(i));
		}
		System.out.println("");
	}

	protected int error_sync_size() {
		return 1;
	}
:}

terminal Token TRACK, EXTENDS, KEEP, VAR, INT, DOB, BOOL, CAR, CAD, TRUE, FALSE;
terminal Token ARRAY, IF, ELSE, SWITCH, CASE,EXIT, DEFAULT, FOR, WHILE, DO_WHILE, CONTINUE, RETURN;
terminal Token PLAY, DO, DO_, RE, RE_, MI, FA, FA_, SOL, SOL_, LA, LA_;
terminal Token WAIT, ORDER, ASC, DESC, EVEN, ODD, PRIME, SUM, LENGTH, MSG, MAIN;
terminal Token ID, INTEGER, DECIMAL, TAB, EQEQ, NEQ, GREATER, SMALLER, GRTREQ, SMLLREQ;
terminal Token NULL, AND, NAND, OR, NOR, XOR, NOT, COMMA, EQUAL, PLUS, MINUS, TIMES, DIVIDE, MOD, POW, PLUS_EQ, PLUS_PLUS, MINUS_MINUS;
terminal Token LBRACE, RBRACE, LBRACKET, RBRACKET, LPAREN, RPAREN, SEMI, EOL, STR, CHAR;
terminal Token ERROR;

non terminal Integer tab;
non terminal Token type;
non terminal Boolean keep;
non terminal Operation value;
non terminal List<Token> id_list;
non terminal List<Assignment> statement;
non terminal Assignment assignment, assign;
non terminal eol, eol_;
non terminal array_statement, dimension, dimensions, array_value, value_list;
non terminal list, fn, list_fn;
non terminal Operation a, b, c, d, e, f, g, h, i, j;
non terminal Variable boolean_val;
non terminal l;
non terminal if_, else_, else_if;
non terminal for_, for_assig, while_, do_while, switch_, case_, default_, exit_, continue_, return_;
non terminal inicio1, extends_;
non terminal body, bod;
non terminal function, params_f, params, param;

start with inicio1;

inicio1 ::=
			eol TRACK ID extends_ bod
			;

extends_ ::=
			EXTENDS id_list
			|
			;

bod ::=
			body
			| body eol_
			;

body ::=
			body statement:list // statement -> ArrayList<Assignment>
				{:
					SymbolTable table = new SymbolTable();
					for(Assignment a : list) {
						a.run(table);
					}

					for(Variable v : table) {
						System.out.println(v);
					}
				:}
			| body assign
			| body array_statement
			| body for_
			| body if_
			| body else_
			| body else_if
			| body while_
			| body do_while
			| body switch_
			| body case_
			| body default_
			| body exit_
			| body continue_
			| body return_
			| body function
			|
			;

/* declaracion de variables */
statement ::=
			eol_ tab:t keep:keep VAR type:token id_list:list value:operation
				{:
					RESULT = new ArrayList<Assignment>();
					for(Token id : list) {
						RESULT.add(new Assignment(keep, token, id, operation));
					}
				:}
			;

value ::=
			EQUAL a:operation {: RESULT = operation; :}
			|{: RESULT = null; :}
			;

id_list ::=
			id_list:list COMMA ID:token
				{:
					list.add(token);
					RESULT = list;
				:}
			| ID:token
				{:
					RESULT = new ArrayList<Token>();
					RESULT.add(token);
				:}
			;

type ::=
			INT:token {: RESULT = token; :}
			| DOB:token {: RESULT = token; :}
			| BOOL:token {: RESULT = token; :}
			| CAD:token {: RESULT = token; :}
			| CAR:token {: RESULT = token; :}
			;

/* asignacion de variables */
assign ::=
			eol_ tab assignment:assign {: RESULT = assign; :}
			;

assignment ::=
			ID:token EQUAL a:operation
				{: RESULT = new Assignment(token, operation); :}
			| ID:token PLUS_EQ a:operation
				{:
					/* Revisar esto */
					Operation tmp = new Operation(OperationType.SUM, new Operation(OperationType.ID, new Variable(token)), operation);
					RESULT = new Assignment(token, tmp);
				:}
			| ID:token PLUS_PLUS
			| ID:token MINUS_MINUS
			| l EQUAL a /* asignacion a arreglos */
			| l PLUS_EQ a
			| l PLUS_PLUS
			| l MINUS_MINUS
			;

l ::=
			ID dimensions
			;

/* declaracion de arreglos */
array_statement ::=
			eol_ tab keep VAR type ARRAY id_list dimensions array_value
			;

dimensions ::=
			dimensions dimension
			| dimension
			;

dimension ::=
			LBRACKET a RBRACKET
			;

array_value ::=
			EQUAL list
			|
			;

list ::=
			LBRACE value_list RBRACE
			| LBRACE list_fn RBRACE
			;

list_fn ::=
			list_fn COMMA fn
			| fn
			;

fn ::=
			list
			;

value_list ::=
			value_list COMMA a
			| a
			;
/* declaracion de arreglos */

/* Operaciones logicas y aritmeticas */
a ::=
			a:l OR b:r {: RESULT = new Operation(OperationType.OR, l, r); :}
			| a:l NOR b:r {: RESULT = new Operation(OperationType.NOR, l, r); :}
			| a:l XOR b:r {: RESULT = new Operation(OperationType.XOR, l, r); :}
			| b:op {: RESULT = op; :}
			;

b ::=
			b:l AND c:r {: RESULT = new Operation(OperationType.AND, l, r); :}
			| b:l NAND c:r {: RESULT = new Operation(OperationType.NAND, l, r); :}
			| c:op {: RESULT = op; :}
			;

c ::=
			c:l EQEQ d:r {: RESULT = new Operation(OperationType.EQEQ, l, r); :}
			| c:l NEQ d:r {: RESULT = new Operation(OperationType.NEQ, l, r); :}
			| c:l GREATER d:r {: RESULT = new Operation(OperationType.GREATER, l, r); :}
			| c:l SMALLER d:r {: RESULT = new Operation(OperationType.SMALLER, l, r); :}
			| c:l GRTREQ d:r {: RESULT = new Operation(OperationType.GREATER_OR_EQUAL, l, r); :}
			| c:l SMLLREQ d:r {: RESULT = new Operation(OperationType.LESS_OR_EQUAL, l, r); :}
			| d:op {: RESULT = op; :}
			;

d ::=
			d:l PLUS e:r {: RESULT = new Operation(OperationType.SUM, l, r); :}
			| d:l MINUS e:r {: RESULT = new Operation(OperationType.SUBTRACTION, l, r); :}
			| e:op {: RESULT = op; :}
			;

e ::=
			e:l TIMES f:r {: RESULT = new Operation(OperationType.MULTIPLICATION, l, r); :}
			| e:l DIVIDE f:r {: RESULT =new Operation(OperationType.DIVISION, l, r); :}
			| e:l MOD f:r {: RESULT = new Operation(OperationType.MOD, l, r); :}
			| f:op {: RESULT = op; :}
			;

f ::=
			g:l POW f:r {: RESULT = new Operation(OperationType.POW, l, r); :}
			| g:op {: RESULT = op; :}
			;

g ::=
			MINUS h:l {: RESULT = new Operation(OperationType.UMINUS, l); :}
			| h:op {: RESULT = op; :}
			;

h ::=
			NOT i:l {: RESULT = new Operation(OperationType.NOT, l); :}
			| i:op {: RESULT = op; :}
			;

i ::=
			NULL j:l {: RESULT = new Operation(OperationType.NULL, l); :}
			| j:op {: RESULT = op; :}
			;

j ::=
			INTEGER:var {: RESULT = new Operation(OperationType.INTEGER, new Variable(Var.INTEGER, var.getValue())); :}
			| DECIMAL:var {: RESULT = new Operation(OperationType.DOUBLE, new Variable(Var.DOUBLE, var.getValue())); :}
			| STR:var {: RESULT = new Operation(OperationType.STRING, new Variable(Var.STRING, var.getValue())); :}
			| CHAR:var {: RESULT = new Operation(OperationType.CHAR, new Variable(Var.CHAR, var.getValue())); :}
			| boolean_val:var {: RESULT = new Operation(OperationType.BOOLEAN, var); :}
			| ID:token {: RESULT = new Operation(OperationType.ID, new Variable(token)); :}
			| l /* arreglo */
			| LPAREN a:var RPAREN {: RESULT = var; :}
			;

boolean_val ::=
			TRUE:var {: RESULT = new Variable(Var.BOOLEAN, var.getValue()); :}
			| FALSE:var {: RESULT = new Variable(Var.BOOLEAN, var.getValue()); :}
			;
/* Operaciones logicas y aritmeticas */

keep ::=
			KEEP {: RESULT = true; :}
			|{: RESULT = false; :}
			;

tab ::=
			tab:t TAB {: RESULT = t + 1; :}
			| TAB {: RESULT = 0; :}
			;

eol_ ::=
			eol_ EOL
			| EOL
			;

eol ::=
			eol EOL
			|
			;

if_ ::=
			eol_ tab IF LPAREN a RPAREN
			;

else_ ::=
			eol_ tab ELSE
			;

else_if ::=
			eol_ tab ELSE IF LPAREN a RPAREN
			;
/* if - si */

/* for - para */
for_ ::=
			eol_ tab FOR LPAREN for_assig SEMI a SEMI assignment RPAREN
			;

for_assig ::=
			VAR INT ID EQUAL a
			| assignment
			;
/* for - para */

/* while - mientras */
while_ ::=
			eol_ tab WHILE LPAREN a RPAREN
			;

/* do-while - hacer-mientras */
do_while ::=
			eol_ tab DO_WHILE
			;
/* do-while - hacer-mientras */

/* switch  */
switch_ ::=
			eol_ tab SWITCH LPAREN a RPAREN
			;

case_ ::=
			eol_ tab CASE a
			;

default_ ::=
			eol_ tab DEFAULT
			;
/* switch  */

/* continue - exit - return */
exit_ ::=
			eol_ tab EXIT
			;

continue_ ::=
			eol_ tab CONTINUE
			;

return_ ::=
			eol_ tab RETURN a
			;
/* continue - exit return */

/*  functions */
function ::=
			eol_ tab ID LPAREN params_f RPAREN // no keep - void
			| eol_ tab KEEP type ID LPAREN params_f RPAREN // keep - type
			| eol_ tab KEEP ID LPAREN params_f RPAREN // keep - void
			| eol_ tab type ID LPAREN params_f RPAREN // no keep - type
			| eol_ tab MAIN LPAREN RPAREN
			;

params_f ::=
			params
			|
			;

params ::=
			params COMMA param
			| param
			;

param ::=
			type ID
			;
/*  functions */
