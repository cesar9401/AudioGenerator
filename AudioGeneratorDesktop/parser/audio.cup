
package com.cesar31.audiogenerator.parser;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import com.cesar31.audiogenerator.instruction.*;
import java.util.Stack;

class AudioParser;

parser code {:
	private Integer min, max;
    private Stack<Ins> stack;

	public AudioParser(AudioLex lex) {
		super(lex);
		this.min = 0;
		this.max = 0;
		this.stack = new Stack<>();
	}

	public Stack<Ins> getStack() {
		return this.stack;
	}

	public void syntax_error(Symbol cur_token) {
		List<String> expected = new ArrayList<>();
		List<Integer> tokens = expected_token_ids();

		System.out.printf("Se encontro: %s -> (%s), linea %d columna %d, se esperaba -> ", cur_token.value, symbl_name_from_id(cur_token.sym), cur_token.left, cur_token.right);
		for(Integer i : tokens) {
			// expected.add(symbl_name_from_id(i));
			System.out.printf("%s, ", symbl_name_from_id(i));
		}
		System.out.println("");
	}

	protected int error_sync_size() {
		return 1;
	}
:}

terminal Token TRACK, EXTENDS, KEEP, VAR, INT, DOB, BOOL, CAR, CAD, TRUE, FALSE;
terminal Token ARRAY, IF, ELSE, SWITCH, CASE,EXIT, DEFAULT, FOR, WHILE, DO_WHILE, CONTINUE, RETURN;
terminal Token PLAY, DO, DO_, RE, RE_, MI, FA, FA_, SOL, SOL_, LA, LA_;
terminal Token WAIT, ORDER, ASC, DESC, EVEN, ODD, PRIME, SUM, LENGTH, MSG, MAIN;
terminal Token ID, INTEGER, DECIMAL, TAB, EQEQ, NEQ, GREATER, SMALLER, GRTREQ, SMLLREQ;
terminal Token NULL, AND, NAND, OR, NOR, XOR, NOT, COMMA, EQUAL, PLUS, MINUS, TIMES, DIVIDE, MOD, POW, PLUS_EQ, PLUS_PLUS, MINUS_MINUS;
terminal Token LBRACE, RBRACE, LBRACKET, RBRACKET, LPAREN, RPAREN, SEMI, EOL, STR, CHAR;
terminal Token ERROR;

non terminal Integer tab;
non terminal Token type;
non terminal Boolean keep;
non terminal Operation value;
non terminal List<Token> id_list;
non terminal List<Assignment> statement;
non terminal Assignment assignment, assign;
non terminal List<Instruction> body, bod, inicio1;
non terminal If if_, else_, else_if;
non terminal Variable boolean_val;
non terminal Operation a, b, c, d, e, f, g, h, i, j;
non terminal While while_;

non terminal eol, eol_;
non terminal array_statement, dimension, dimensions, array_value, value_list;
non terminal list, fn, list_fn;
non terminal l;
non terminal for_, for_assig, do_while, switch_, case_, default_, exit_, continue_, return_;
non terminal extends_;
non terminal function, params_f, params, param;

start with inicio1;

inicio1 ::=
			eol TRACK ID extends_ bod:list_i
				{:
					RESULT = list_i;
				:}
			;

extends_ ::=
			EXTENDS id_list
			|
			;

bod ::=
			body:list_i
				{: RESULT = list_i; :}
			| body:list_i eol_
				{: RESULT = list_i; :}
			;

body ::=
			body:list_i statement:list // statement -> ArrayList<Assignment>
				{:
					//System.out.println("statement");
					RESULT = list_i;
					// list_i.addAll(list);
				:}
			| body:list_i assign:assign
				{:
					RESULT = list_i;
					if(stack.isEmpty()) {
						RESULT.add(assign);
					} else if(stack.peek().getTab() + 1 == assign.getTab()) {
						/* instruccion hijo */
						stack.peek().getInstructions().add(assign);
					} else if(stack.peek().getTab() == assign.getTab()) {
						/* instruccion hermano */
						Ins tmp = stack.pop();
						RESULT.add((Instruction)tmp);
						stack.peek().getInstructions().add(assign);
					} else {
						System.out.println("revisar posicion assig");
					}
				:}
			| body:list_i array_statement
			| body:list_i for_
			| body:list_i if_:if_
				{:
					// if(stack.peek() != null && stack.peek().getTab() + 1 == if_.getTab()) {
					// 	stack.push(if_);
					// } else if(stack.peek().getTab() == if_.getTab()) {
					// 	stack.peek().getInstructions.add(if_);
					// 	stack.push(if_);
					// }
					RESULT = list_i;
					//RESULT.add(if_);
				:}
			| body:list_i else_
			| body:list_i else_if
			| body:list_i while_:wh
				{:
					RESULT = list_i;
					if(stack.isEmpty()) {
						stack.push(wh);
					} else if(stack.peek().getTab() + 1 == wh.getTab()) {
						/* while hijo */
						stack.peek().getInstructions().add(wh);
						stack.push(wh);
					} else if(stack.peek().getTab() == wh.getTab()) {
						/* while hermano */
						Ins tmp = stack.pop();
						stack.peek().getInstructions().add(wh);
						stack.push(wh);
					} else {
						/* revisar */
						System.out.println("While afuera");
					}
				:}
			| body:list_i do_while
			| body:list_i switch_
			| body:list_i case_
			| body:list_i default_
			| body:list_i exit_
			| body:list_i continue_
			| body:list_i return_
			| body:list_i function
				{:
					System.out.println("function");
					RESULT = list_i;
				:}
			|
				{: RESULT = new ArrayList<Instruction>(); :}
			;

/* declaracion de variables */
statement ::=
			eol_ tab:t keep:keep VAR type:token id_list:list value:operation
				{:
					if(min <= t && t <= max) {
						max = t;
					} else {
						System.out.println("statement mal identado");
					}

					RESULT = new ArrayList<Assignment>();
					for(Token id : list) {
						RESULT.add(new Assignment(t, keep, token, id, operation));
					}
				:}
			;

value ::=
			EQUAL a:operation {: RESULT = operation; :}
			|{: RESULT = null; :}
			;

id_list ::=
			id_list:list COMMA ID:token
				{:
					list.add(token);
					RESULT = list;
				:}
			| ID:token
				{:
					RESULT = new ArrayList<Token>();
					RESULT.add(token);
				:}
			;

type ::=
			INT:token {: RESULT = token; :}
			| DOB:token {: RESULT = token; :}
			| BOOL:token {: RESULT = token; :}
			| CAD:token {: RESULT = token; :}
			| CAR:token {: RESULT = token; :}
			;

/* asignacion de variables */
assign ::=
			eol_ tab:t assignment:assign
				{:
					assign.setTab(t);
					RESULT = assign;
					if(min <= t && t <= max) {
						max = t;
					} else {
						System.out.println("Assignment mal identado!");
					}
				:}
			;

assignment ::=
			ID:token EQUAL a:operation
				{: RESULT = new Assignment(token, operation); :}
			| ID:token PLUS_EQ a:operation
				{:
					/* Revisar esto */
					Operation tmp = new Operation(OperationType.SUM, new Operation(OperationType.ID, new Variable(token)), operation);
					RESULT = new Assignment(token, tmp);
				:}
			| ID:token PLUS_PLUS
			| ID:token MINUS_MINUS
			| l EQUAL a /* asignacion a arreglos */
			| l PLUS_EQ a
			| l PLUS_PLUS
			| l MINUS_MINUS
			;

l ::=
			ID dimensions
			;

/* declaracion de arreglos */
array_statement ::=
			eol_ tab keep VAR type ARRAY id_list dimensions array_value
			;

dimensions ::=
			dimensions dimension
			| dimension
			;

dimension ::=
			LBRACKET a RBRACKET
			;

array_value ::=
			EQUAL list
			|
			;

list ::=
			LBRACE value_list RBRACE
			| LBRACE list_fn RBRACE
			;

list_fn ::=
			list_fn COMMA fn
			| fn
			;

fn ::=
			list
			;

value_list ::=
			value_list COMMA a
			| a
			;
/* declaracion de arreglos */

/* Operaciones logicas y aritmeticas */
a ::=
			a:l OR b:r {: RESULT = new Operation(OperationType.OR, l, r); :}
			| a:l NOR b:r {: RESULT = new Operation(OperationType.NOR, l, r); :}
			| a:l XOR b:r {: RESULT = new Operation(OperationType.XOR, l, r); :}
			| b:op {: RESULT = op; :}
			;

b ::=
			b:l AND c:r {: RESULT = new Operation(OperationType.AND, l, r); :}
			| b:l NAND c:r {: RESULT = new Operation(OperationType.NAND, l, r); :}
			| c:op {: RESULT = op; :}
			;

c ::=
			c:l EQEQ d:r {: RESULT = new Operation(OperationType.EQEQ, l, r); :}
			| c:l NEQ d:r {: RESULT = new Operation(OperationType.NEQ, l, r); :}
			| c:l GREATER d:r {: RESULT = new Operation(OperationType.GREATER, l, r); :}
			| c:l SMALLER d:r {: RESULT = new Operation(OperationType.SMALLER, l, r); :}
			| c:l GRTREQ d:r {: RESULT = new Operation(OperationType.GREATER_OR_EQUAL, l, r); :}
			| c:l SMLLREQ d:r {: RESULT = new Operation(OperationType.LESS_OR_EQUAL, l, r); :}
			| d:op {: RESULT = op; :}
			;

d ::=
			d:l PLUS e:r {: RESULT = new Operation(OperationType.SUM, l, r); :}
			| d:l MINUS e:r {: RESULT = new Operation(OperationType.SUBTRACTION, l, r); :}
			| e:op {: RESULT = op; :}
			;

e ::=
			e:l TIMES f:r {: RESULT = new Operation(OperationType.MULTIPLICATION, l, r); :}
			| e:l DIVIDE f:r {: RESULT =new Operation(OperationType.DIVISION, l, r); :}
			| e:l MOD f:r {: RESULT = new Operation(OperationType.MOD, l, r); :}
			| f:op {: RESULT = op; :}
			;

f ::=
			g:l POW f:r {: RESULT = new Operation(OperationType.POW, l, r); :}
			| g:op {: RESULT = op; :}
			;

g ::=
			MINUS h:l {: RESULT = new Operation(OperationType.UMINUS, l); :}
			| h:op {: RESULT = op; :}
			;

h ::=
			NOT i:l {: RESULT = new Operation(OperationType.NOT, l); :}
			| i:op {: RESULT = op; :}
			;

i ::=
			NULL j:l {: RESULT = new Operation(OperationType.NULL, l); :}
			| j:op {: RESULT = op; :}
			;

j ::=
			INTEGER:var {: RESULT = new Operation(OperationType.INTEGER, new Variable(Var.INTEGER, var.getValue())); :}
			| DECIMAL:var {: RESULT = new Operation(OperationType.DOUBLE, new Variable(Var.DOUBLE, var.getValue())); :}
			| STR:var {: RESULT = new Operation(OperationType.STRING, new Variable(Var.STRING, var.getValue())); :}
			| CHAR:var {: RESULT = new Operation(OperationType.CHAR, new Variable(Var.CHAR, var.getValue())); :}
			| boolean_val:var {: RESULT = new Operation(OperationType.BOOLEAN, var); :}
			| ID:token {: RESULT = new Operation(OperationType.ID, new Variable(token)); :}
			| l /* arreglo */
			| LPAREN a:var RPAREN {: RESULT = var; :}
			;

boolean_val ::=
			TRUE:var {: RESULT = new Variable(Var.BOOLEAN, var.getValue()); :}
			| FALSE:var {: RESULT = new Variable(Var.BOOLEAN, var.getValue()); :}
			;
/* Operaciones logicas y aritmeticas */

keep ::=
			KEEP {: RESULT = true; :}
			|{: RESULT = false; :}
			;

tab ::=
			tab:t TAB {: RESULT = t + 1; :}
			| TAB {: RESULT = 0; :}
			;

eol_ ::=
			eol_ EOL
			| EOL
			;

eol ::=
			eol EOL
			|
			;

if_ ::=
			eol_ tab:t IF LPAREN a:condition RPAREN
				{:
					RESULT = new If(t, condition);
					if(t >= 1 && min <= t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("If mal identado");
					}
				:}
			;

else_ ::=
			eol_ tab:t ELSE
				{:
					System.out.println("else -> " + t);
					if(t >=1 && min <= t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("Else mal identado");
					}
				:}
			;

else_if ::=
			eol_ tab:t ELSE IF LPAREN a RPAREN
				{:
					System.out.println("else_if -> " + t);
					if(t >=1 && min <=t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("Else_if mal identado");
					}
				:}
			;
/* if - si */

/* for - para */
for_ ::=
			eol_ tab:t FOR LPAREN for_assig SEMI a SEMI assignment RPAREN
				{:
					System.out.println("for -> " + t);
					if(t >=1 && min <= t && t <= max) {
						System.out.println("For here!");
						max = t + 1;
					} else {
						System.out.println("For mal identado");
					}
				:}
			;

for_assig ::=
			VAR INT ID EQUAL a
			| assignment
			;
/* for - para */

/* while - mientras */
while_ ::=
			eol_ tab:t WHILE LPAREN a:condition RPAREN
				{:
					RESULT = new While(t, condition);
					System.out.println("while -> " + t);
					if(t >=1 && min <= t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("While mal identado");
					}
				:}
			;

/* do-while - hacer-mientras */
do_while ::=
			eol_ tab:t DO_WHILE
				{:
					System.out.println("do_while -> " + t);
					if(t >= 1 && min <=t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("Do_while mal identado");
					}
				:}
			;
/* do-while - hacer-mientras */

/* switch  */
switch_ ::=
			eol_ tab SWITCH LPAREN a RPAREN
			;

case_ ::=
			eol_ tab CASE a
			;

default_ ::=
			eol_ tab DEFAULT
			;
/* switch  */

/* continue - exit - return */
exit_ ::=
			eol_ tab EXIT
			;

continue_ ::=
			eol_ tab CONTINUE
			;

return_ ::=
			eol_ tab RETURN a
			;
/* continue - exit return */

/*  functions */
function ::=
			eol_ tab ID LPAREN params_f RPAREN // no keep - void
			| eol_ tab KEEP type ID LPAREN params_f RPAREN // keep - type
			| eol_ tab KEEP ID LPAREN params_f RPAREN // keep - void
			| eol_ tab type ID LPAREN params_f RPAREN // no keep - type
			| eol_ tab:t MAIN LPAREN RPAREN
				{:
					System.out.println("main -> " + t);
					if(t != 0) {
						System.out.println("Error, metodo main mal identado");
					} else {
						min = t + 1;
						max = t + 1;
					}
				:}
			;

params_f ::=
			params
			|
			;

params ::=
			params COMMA param
			| param
			;

param ::=
			type ID
			;
/*  functions */
