
package com.cesar31.audiogenerator.parser;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.lang.reflect.Array;

import com.cesar31.audiogenerator.instruction.*;
import com.cesar31.audiogenerator.control.*;
import com.cesar31.audiogenerator.error.*;

class AudioParser;

parser code {:
	private Integer min, max;
	private StackHandler stackHandler;
	private ErrorHandler errorHandler;

	private List<Integer> ind;

	public AudioParser(AudioLex lex) {
		super(lex);
		this.min = 0;
		this.max = 0;
		this.stackHandler = new StackHandler();
		this.errorHandler = new ErrorHandler();
		this.ind = new ArrayList<>();
	}

	public Stack<Ins> getStack() {
		return this.stackHandler.getStack();
	}

	public List<Err> getErrors() {
		return this.errorHandler.getErrors();
	}

	public void syntax_error(Symbol cur_token) {
		List<String> expected = new ArrayList<>();
		List<Integer> tokens = expected_token_ids();

		// System.out.printf("Se encontro: %s -> (%s), linea %d columna %d, se esperaba -> ", cur_token.value, symbl_name_from_id(cur_token.sym), cur_token.left, cur_token.right);
		for(Integer i : tokens) {
			expected.add(symbl_name_from_id(i));
			// System.out.printf("%s, ", symbl_name_from_id(i));
		}
		this.errorHandler.setError((Token) cur_token.value, symbl_name_from_id(cur_token.sym), expected);
	}

	protected int error_sync_size() {
		return 1;
	}
:}

terminal Token TRACK, EXTENDS, KEEP, VAR, INT, DOB, BOOL, CAR, CAD, TRUE, FALSE;
terminal Token ARRAY, IF, ELSE, SWITCH, CASE,EXIT, DEFAULT, FOR, WHILE, DO_WHILE, CONTINUE, RETURN;
terminal Token PLAY, DO, DO_, RE, RE_, MI, FA, FA_, SOL, SOL_, LA, LA_;
terminal Token WAIT, ORDER, ASC, DESC, EVEN, ODD, PRIME, SUM, LENGTH, MSG, MAIN;
terminal Token ID, INTEGER, DECIMAL, TAB, EQEQ, NEQ, GREATER, SMALLER, GRTREQ, SMLLREQ;
terminal Token NULL, AND, NAND, OR, NOR, XOR, NOT, COMMA, EQUAL, PLUS, MINUS, TIMES, DIVIDE, MOD, POW, PLUS_EQ, PLUS_PLUS, MINUS_MINUS;
terminal Token LBRACE, RBRACE, LBRACKET, RBRACKET, LPAREN, RPAREN, SEMI, EOL, STR, CHAR;
terminal Token ERROR;

non terminal Integer tab;
non terminal Token type;
non terminal Boolean keep;
non terminal Operation value;
non terminal List<Token> id_list;
non terminal List<Assignment> statement;
non terminal Assignment assignment, assign, for_assign;
non terminal List<Instruction> body, bod, inicio1;
non terminal If if_, else_, else_if;
non terminal Variable boolean_val;
non terminal Operation a, b, c, d, e, f, g, h, i, j, dimension;
non terminal List<Operation> dimensions, value_list;
non terminal While while_;
non terminal Instruction function;
non terminal Principal principal;
non terminal Message message;
non terminal For for_;
non terminal DoWhile do_while;
non terminal List<ArrayAssignment> array_statement;
non terminal Object list, fn;
non terminal List<Object> list_fn;
non terminal ArrayAccess l;

non terminal eol, eol_;
non terminal array_value;
non terminal switch_, case_, default_, exit_, continue_, return_;
non terminal extends_;
non terminal params_f, params, param;

start with inicio1;

inicio1 ::=
			eol TRACK ID extends_ bod:list_i
				{:
					RESULT = list_i;
					if(!getStack().isEmpty()) {
						for(Ins i : getStack()) {
							if(i.isInAst()) {
								RESULT.add((Instruction) i);
							}
						}
					}
				:}
			;

extends_ ::=
			EXTENDS id_list
			|
			;

bod ::=
			body:list_i
				{: RESULT = list_i; :}
			| body:list_i eol_
				{: RESULT = list_i; :}
			;

body ::=
			body:list_i statement:list // statement -> ArrayList<Assignment>
				{:
					RESULT = list_i;
					for(Assignment a : list) {
						stackHandler.checkStackForInstructionsNonFather(RESULT , a);
					}
				:}
			| body:list_i assign:assign
				{: RESULT = list_i; stackHandler.checkStackForInstructionsNonFather(RESULT, assign); :}
			| body:list_i array_statement:array_assign // array_statement -> ArrayList<ArrayAssignment>
				{:
					RESULT = list_i;
					for(ArrayAssignment a : array_assign) {
						stackHandler.checkStackForInstructionsNonFather(RESULT, a);
					}
				:}
			| body:list_i for_:for_
				{: RESULT = list_i; stackHandler.checkStackForInstructionsFather(RESULT, for_); :}
			| body:list_i if_:if_
				{: RESULT = list_i; stackHandler.checkStackForInstructionsIf(RESULT, if_); :}
			| body:list_i else_:else_
				{: RESULT = list_i; stackHandler.checkStackForInstructionsIf(RESULT, else_); :}
			| body:list_i else_if:else_if
				{: RESULT = list_i; stackHandler.checkStackForInstructionsIf(RESULT, else_if); :}
			| body:list_i while_:wh
				{: RESULT = list_i; stackHandler.checkStackForInstructionsFather(RESULT, wh); :}
			| body:list_i do_while:do_while
				{: RESULT = list_i; stackHandler.checkStackForInstructionsFather(RESULT, do_while); :}
			| body:list_i switch_
			| body:list_i case_
			| body:list_i default_
			| body:list_i exit_
			| body:list_i continue_
			| body:list_i return_
			| body:list_i function
				{: RESULT = list_i; :}
			| body:list_i principal:principal
				{: RESULT = list_i; stackHandler.checkStackForInstructionsFather(RESULT, principal); :}
			| body:list_i message:message
				{: RESULT = list_i; stackHandler.checkStackForInstructionsNonFather(RESULT, message); :}
			|
				{: RESULT = new ArrayList<Instruction>(); :}
			;


/* declaracion de variables */
statement ::=
			eol_ tab:t keep:keep VAR type:token id_list:list value:operation
				{:
					if(min <= t && t <= max) {
						max = t;
					} else if(t == 0) {
						min = 0;
						max = 0;
					} else {
						System.out.println("statement mal identado");
					}

					RESULT = new ArrayList<Assignment>();
					for(Token id : list) {
						RESULT.add(new Assignment(t, keep, token, id, operation));
					}
				:}
			;

value ::=
			EQUAL a:operation {: RESULT = operation; :}
			|{: RESULT = null; :}
			;

id_list ::=
			id_list:list COMMA ID:token
				{:
					list.add(token);
					RESULT = list;
				:}
			| ID:token
				{:
					RESULT = new ArrayList<Token>();
					RESULT.add(token);
				:}
			;

type ::=
			INT:token {: RESULT = token; :}
			| DOB:token {: RESULT = token; :}
			| BOOL:token {: RESULT = token; :}
			| CAD:token {: RESULT = token; :}
			| CAR:token {: RESULT = token; :}
			;

/* asignacion de variables */
assign ::=
			eol_ tab:t assignment:assign
				{:
					assign.setTab(t);
					RESULT = assign;
					if(t >= 1 && min <= t && t <= max) {
						max = t;
					} else {
						System.out.println("Assignment mal identado!");
					}
				:}
			;

assignment ::=
			ID:token EQUAL a:operation
				{: RESULT = new Assignment(token, operation); :}
			| ID:token PLUS_EQ a:operation
				{:
					Operation tmp = new Operation(OperationType.SUM, new Operation(OperationType.ID, new Variable(token)), operation);
					RESULT = new Assignment(token, tmp);
				:}
			| ID:token PLUS_PLUS
				{:
					Operation tmp = new Operation(OperationType.SUM, new Operation(OperationType.ID, new Variable(token)), new Operation(OperationType.INTEGER, new Variable(Var.INTEGER, "1")));
					RESULT = new Assignment(token, tmp);
				:}
			| ID:token MINUS_MINUS
				{:
					Operation tmp = new Operation(OperationType.SUBTRACTION, new Operation(OperationType.ID, new Variable(token)), new Operation(OperationType.INTEGER, new Variable(Var.INTEGER, "1")));
					RESULT = new Assignment(token, tmp);
				:}
			/* asignacion a arreglos */
			| l:array_access EQUAL a
			| l:array_access PLUS_EQ a
			| l:array_access PLUS_PLUS
			| l:array_access MINUS_MINUS
			;

l ::=
			ID:token_id dimensions:list_operation
				{: RESULT = new ArrayAccess(token_id, list_operation); :}
			;

/* declaracion de arreglos */
array_statement ::=
			eol_ tab:t keep:keep VAR type:type ARRAY id_list:list_token dimensions:dimensions array_value:array_list
				{:
					if(min <= t && t <= max) {
						max = t;
					} else if(t == 0) {
						min = 0;
						max = 0;
					} else {
						System.out.println("Array-Assignment mal identado");
					}

					RESULT = new ArrayList<>();
					for(Token id : list_token) {
						RESULT.add(new ArrayAssignment(t, keep, type, id, dimensions, array_list, ind));
					}
					ind = new ArrayList<>();
				:}
			;

dimensions ::=
			dimensions:list_op dimension:operation
				{: RESULT = list_op; RESULT.add(operation); :}
			| dimension:operation
				{: RESULT = new ArrayList<>(); RESULT.add(operation); :}
			;

dimension ::=
			LBRACKET a:operation RBRACKET
				{: RESULT = operation; :}
			;

array_value ::=
			EQUAL list:list {: RESULT = list; :}
			| {: RESULT = null; :}
			;

list ::=
			LBRACE value_list:list_op RBRACE
				{:
					RESULT = Array.newInstance(Operation.class, list_op.size());
					ind.add(list_op.size());
					// System.out.println(list_op.size());
					for(int i = 0; i < list_op.size(); i++) {
						Array.set(RESULT, i, list_op.get(i));
					}
				:}
			| LBRACE list_fn:list_fn RBRACE
				{:
					RESULT = Array.newInstance(Object.class, list_fn.size());
					for(int i = 0; i < list_fn.size(); i++) {
						Array.set(RESULT, i, list_fn.get(i));
					}
				:}
			;

list_fn ::=
			list_fn:list_fn COMMA fn:fn
				{: RESULT = list_fn; RESULT.add(fn); :}
			| fn:fn
				{: RESULT = new ArrayList<>(); RESULT.add(fn); :}
			;

fn ::=
			list:list_op
				{: RESULT = list_op; :}
			;

value_list ::=
			value_list:list COMMA a:operation
				{: RESULT = list; RESULT.add(operation); :}
			| a:operation
				{: RESULT = new ArrayList<>(); RESULT.add(operation); :}
			;
/* declaracion de arreglos */

/* Operaciones logicas y aritmeticas */
a ::=
			a:l OR b:r {: RESULT = new Operation(OperationType.OR, l, r); :}
			| a:l NOR b:r {: RESULT = new Operation(OperationType.NOR, l, r); :}
			| a:l XOR b:r {: RESULT = new Operation(OperationType.XOR, l, r); :}
			| b:op {: RESULT = op; :}
			;

b ::=
			b:l AND c:r {: RESULT = new Operation(OperationType.AND, l, r); :}
			| b:l NAND c:r {: RESULT = new Operation(OperationType.NAND, l, r); :}
			| c:op {: RESULT = op; :}
			;

c ::=
			c:l EQEQ d:r {: RESULT = new Operation(OperationType.EQEQ, l, r); :}
			| c:l NEQ d:r {: RESULT = new Operation(OperationType.NEQ, l, r); :}
			| c:l GREATER d:r {: RESULT = new Operation(OperationType.GREATER, l, r); :}
			| c:l SMALLER d:r {: RESULT = new Operation(OperationType.SMALLER, l, r); :}
			| c:l GRTREQ d:r {: RESULT = new Operation(OperationType.GREATER_OR_EQUAL, l, r); :}
			| c:l SMLLREQ d:r {: RESULT = new Operation(OperationType.LESS_OR_EQUAL, l, r); :}
			| d:op {: RESULT = op; :}
			;

d ::=
			d:l PLUS e:r {: RESULT = new Operation(OperationType.SUM, l, r); :}
			| d:l MINUS e:r {: RESULT = new Operation(OperationType.SUBTRACTION, l, r); :}
			| e:op {: RESULT = op; :}
			;

e ::=
			e:l TIMES f:r {: RESULT = new Operation(OperationType.MULTIPLICATION, l, r); :}
			| e:l DIVIDE f:r {: RESULT =new Operation(OperationType.DIVISION, l, r); :}
			| e:l MOD f:r {: RESULT = new Operation(OperationType.MOD, l, r); :}
			| f:op {: RESULT = op; :}
			;

f ::=
			g:l POW f:r {: RESULT = new Operation(OperationType.POW, l, r); :}
			| g:op {: RESULT = op; :}
			;

g ::=
			MINUS h:l {: RESULT = new Operation(OperationType.UMINUS, l); :}
			| h:op {: RESULT = op; :}
			;

h ::=
			NOT i:l {: RESULT = new Operation(OperationType.NOT, l); :}
			| i:op {: RESULT = op; :}
			;

i ::=
			NULL j:l {: RESULT = new Operation(OperationType.NULL, l); :}
			| j:op {: RESULT = op; :}
			;

j ::=
			INTEGER:var {: RESULT = new Operation(OperationType.INTEGER, new Variable(Var.INTEGER, var.getValue())); :}
			| DECIMAL:var {: RESULT = new Operation(OperationType.DOUBLE, new Variable(Var.DOUBLE, var.getValue())); :}
			| STR:var {: RESULT = new Operation(OperationType.STRING, new Variable(Var.STRING, var.getValue())); :}
			| CHAR:var {: RESULT = new Operation(OperationType.CHAR, new Variable(Var.CHAR, var.getValue())); :}
			| boolean_val:var {: RESULT = new Operation(OperationType.BOOLEAN, var); :}
			| ID:token {: RESULT = new Operation(OperationType.ID, new Variable(token)); :}
			| l:array_access {: RESULT = new Operation(OperationType.ARRAY_ACCESS, array_access); :} /* arreglo */
			| LPAREN a:var RPAREN {: RESULT = var; :}
			;

boolean_val ::=
			TRUE:var {: RESULT = new Variable(Var.BOOLEAN, var.getValue()); :}
			| FALSE:var {: RESULT = new Variable(Var.BOOLEAN, var.getValue()); :}
			;
/* Operaciones logicas y aritmeticas */

keep ::=
			KEEP {: RESULT = true; :}
			|{: RESULT = false; :}
			;

tab ::=
			tab:t TAB {: RESULT = t + 1; :}
			| TAB {: RESULT = 0; :}
			;

eol_ ::=
			eol_ EOL
			| EOL
			;

eol ::=
			eol EOL
			|
			;

if_ ::=
			eol_ tab:t IF LPAREN a:condition RPAREN
				{:
					RESULT = new If(t, If.Type.IF, condition);
					if(t >= 1 && min <= t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("If mal identado");
					}
				:}
			;

else_ ::=
			eol_ tab:t ELSE
				{:
					RESULT = new If(t, If.Type.ELSE, null);
					if(t >=1 && min <= t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("Else mal identado");
					}
				:}
			;

else_if ::=
			eol_ tab:t ELSE IF LPAREN a:condition RPAREN
				{:
					RESULT = new If(t, If.Type.ELSE_IF, condition);
					if(t >=1 && min <=t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("Else_if mal identado");
					}
				:}
			;
/* if - si */

/* for - para */
for_ ::=
			eol_ tab:t FOR LPAREN for_assign:assign SEMI a:condition SEMI assignment:increase RPAREN
				{:
					RESULT = new For(t, assign, condition, increase);
					if(t >=1 && min <= t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("For mal identado");
					}
				:}
			;

for_assign ::=
			VAR INT:type ID:id EQUAL a:operation
				{: RESULT = new Assignment(type, id, operation); :}
			| assignment:assign
				{: RESULT = assign; :}
			;
/* for - para */

/* while - mientras */
while_ ::=
			eol_ tab:t WHILE LPAREN a:condition RPAREN
				{:
					RESULT = new While(t, condition);
					if(t >=1 && min <= t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("While mal identado");
					}
				:}
			;

/* do-while - hacer-mientras */
do_while ::=
			eol_ tab:t DO_WHILE
				{:
					RESULT = new DoWhile(t);
					if(t >= 1 && min <=t && t <= max) {
						max = t + 1;
					} else {
						System.out.println("Do_while mal identado");
					}
				:}
			;
/* do-while - hacer-mientras */

/* switch  */
switch_ ::=
			eol_ tab SWITCH LPAREN a RPAREN
			;

case_ ::=
			eol_ tab CASE a
			;

default_ ::=
			eol_ tab DEFAULT
			;
/* switch  */

/* continue - exit - return */
exit_ ::=
			eol_ tab EXIT
			;

continue_ ::=
			eol_ tab CONTINUE
			;

return_ ::=
			eol_ tab RETURN a
			;
/* continue - exit return */

/*  functions */
function ::=
			eol_ tab ID LPAREN params_f RPAREN // no keep - void
			| eol_ tab KEEP type ID LPAREN params_f RPAREN // keep - type
			| eol_ tab KEEP ID LPAREN params_f RPAREN // keep - void
			| eol_ tab type ID LPAREN params_f RPAREN // no keep - type
			// | eol_ tab:t MAIN LPAREN RPAREN
			;

/* principal */
principal ::=
			eol_ tab:t MAIN LPAREN RPAREN
				{:
					RESULT = new Principal(t);
					if(t != 0) {
						System.out.println("Error, metodo main mal identado");
					} else {
						min = t + 1;
						max = t + 1;
					}
				:}
			;

/* principal */
message ::=
			eol_ tab:t MSG LPAREN a:operation RPAREN
				{:
					RESULT = new Message(t, operation);
					if(t >= 1 && min <= t && t <= max) {
						max = t;
					} else {
						System.out.println("Message mal identado!");
					}
				:}
			;

params_f ::=
			params
			|
			;

params ::=
			params COMMA param
			| param
			;

param ::=
			type ID
			;
/*  functions */
